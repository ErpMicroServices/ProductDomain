package com.erpmicroservices.productdomain.database.steps;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.datatable.DataTable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import javax.sql.DataSource;
import java.sql.*;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
public class DatabaseSetupSteps {

    @Autowired
    private DataSource dataSource;

    private Connection connection;
    private DatabaseMetaData metaData;
    private ResultSet resultSet;

    @Given("a clean PostgreSQL 16 database instance")
    public void aCleanPostgreSQLDatabaseInstance() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Clean up any existing test data
        cleanTestData();
    }

    @Given("the database schema is auto-generated by JPA/Hibernate")
    public void theDatabaseSchemaIsAutoGeneratedByJPAHibernate() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Verify database connection is working
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT 1");
        assertTrue(rs.next(), "Database connection should be working");
        assertEquals(1, rs.getInt(1), "Should return 1");
    }

    @Given("JPA/Hibernate is properly configured")
    public void jpaHibernateIsProperlyConfigured() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        // JPA/Hibernate will auto-create schema, so just verify connection
        assertTrue(connection.isValid(5), "Database connection should be valid");
    }

    @Given("the database connection pool is configured")
    public void theDatabaseConnectionPoolIsConfigured() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Verify we can get a connection (implies pool is working)
        assertNotNull(connection, "Should be able to get database connection");
        assertFalse(connection.isClosed(), "Connection should be open");
    }

    @Given("PostgreSQL specific optimizations are enabled")
    public void postgreSQLSpecificOptimizationsAreEnabled() throws SQLException {
        connection = dataSource.getConnection();
        
        // Verify we're connected to PostgreSQL
        DatabaseMetaData metaData = connection.getMetaData();
        String databaseProductName = metaData.getDatabaseProductName();
        assertEquals("PostgreSQL", databaseProductName, "Should be connected to PostgreSQL");
        
        // Verify PostgreSQL version
        String databaseProductVersion = metaData.getDatabaseProductVersion();
        assertTrue(databaseProductVersion.startsWith("16"), 
                  "Should be using PostgreSQL 16, found: " + databaseProductVersion);
    }

    @When("I connect to the database")
    public void iConnectToTheDatabase() throws SQLException {
        connection = dataSource.getConnection();
        assertNotNull(connection, "Should be able to connect to database");
        assertFalse(connection.isClosed(), "Connection should be open");
    }

    @When("I check the JPA schema generation status")
    public void iCheckTheJPASchemaGenerationStatus() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Check if any tables exist (indicating schema has been generated)
        resultSet = metaData.getTables(null, null, "%", new String[]{"TABLE"});
    }

    @When("I verify the connection pool status")
    public void iVerifyTheConnectionPoolStatus() throws SQLException {
        // Test multiple connections to verify pool is working
        for (int i = 0; i < 3; i++) {
            try (Connection testConnection = dataSource.getConnection()) {
                assertNotNull(testConnection, "Should be able to get connection " + (i + 1));
                assertTrue(testConnection.isValid(5), "Connection " + (i + 1) + " should be valid");
            }
        }
    }

    @When("I query the database metadata")
    public void iQueryTheDatabaseMetadata() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Get basic metadata
        String url = metaData.getURL();
        String userName = metaData.getUserName();
        String databaseProductName = metaData.getDatabaseProductName();
        
        assertNotNull(url, "Database URL should not be null");
        assertNotNull(userName, "Database username should not be null");
        assertEquals("PostgreSQL", databaseProductName, "Should be PostgreSQL");
    }

    @When("I check for required database tables")
    public void iCheckForRequiredDatabaseTables() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // Get all tables
        resultSet = metaData.getTables(null, null, "%", new String[]{"TABLE"});
    }

    @When("I verify database constraints")
    public void iVerifyDatabaseConstraints() throws SQLException {
        connection = dataSource.getConnection();
        metaData = connection.getMetaData();
        
        // This will be populated when JPA entities are created
        // For now, just verify we can query constraints
        Statement stmt = connection.createStatement();
        resultSet = stmt.executeQuery(
            "SELECT tc.constraint_name, tc.table_name, tc.constraint_type " +
            "FROM information_schema.table_constraints tc " +
            "WHERE tc.table_schema = 'public'"
        );
    }

    @Then("the database connection should be established successfully")
    public void theDatabaseConnectionShouldBeEstablishedSuccessfully() throws SQLException {
        assertNotNull(connection, "Database connection should exist");
        assertFalse(connection.isClosed(), "Database connection should be open");
        assertTrue(connection.isValid(5), "Database connection should be valid");
    }

    @Then("the database should be using PostgreSQL version {string}")
    public void theDatabaseShouldBeUsingPostgreSQLVersion(String expectedVersion) throws SQLException {
        String actualVersion = metaData.getDatabaseProductVersion();
        assertTrue(actualVersion.startsWith(expectedVersion), 
                  "Expected PostgreSQL " + expectedVersion + ", but found: " + actualVersion);
    }

    @Then("the connection pool should be working")
    public void theConnectionPoolShouldBeWorking() throws SQLException {
        // Verify we can get multiple connections
        for (int i = 0; i < 5; i++) {
            try (Connection testConnection = dataSource.getConnection()) {
                assertNotNull(testConnection, "Should be able to get connection " + (i + 1));
                Statement stmt = testConnection.createStatement();
                ResultSet rs = stmt.executeQuery("SELECT 1");
                assertTrue(rs.next(), "Query should return result");
            }
        }
    }

    @Then("JPA/Hibernate DDL should be configured")
    public void jpaHibernateDDLShouldBeConfigured() throws SQLException {
        // Verify the connection is working and ready for JPA
        assertNotNull(connection, "Connection should exist for JPA");
        assertTrue(connection.isValid(5), "Connection should be valid for JPA");
        
        // JPA will create tables as needed when entities are defined
        String schema = connection.getSchema();
        assertNotNull(schema, "Database schema should be accessible");
    }

    @Then("the database should support the required features")
    public void theDatabaseShouldSupportTheRequiredFeatures() throws SQLException {
        // Verify PostgreSQL specific features
        assertTrue(metaData.supportsTransactions(), "Should support transactions");
        assertTrue(metaData.supportsMultipleTransactions(), "Should support multiple transactions");
        assertTrue(metaData.supportsOpenCursorsAcrossCommit(), "Should support cursors across commits");
        assertTrue(metaData.supportsStoredProcedures(), "Should support stored procedures");
    }

    @Then("the following database features should be available:")
    public void theFollowingDatabaseFeaturesShouldBeAvailable(DataTable dataTable) throws SQLException {
        List<Map<String, String>> features = dataTable.asMaps(String.class, String.class);
        
        for (Map<String, String> feature : features) {
            String featureName = feature.get("feature");
            String expectedStatus = feature.get("status");
            
            boolean isSupported = checkDatabaseFeature(featureName);
            
            if ("supported".equals(expectedStatus)) {
                assertTrue(isSupported, featureName + " should be supported");
            } else {
                assertFalse(isSupported, featureName + " should not be supported");
            }
        }
    }

    @Then("the connection should use the HikariCP pool")
    public void theConnectionShouldUseTheHikariCPPool() throws SQLException {
        // Verify that we're using HikariCP by checking the connection class
        String connectionClass = connection.getClass().getName();
        assertTrue(connectionClass.contains("Hikari") || connectionClass.contains("hikari"),
                  "Connection should be from HikariCP pool, found: " + connectionClass);
    }

    private boolean checkDatabaseFeature(String featureName) throws SQLException {
        switch (featureName.toLowerCase()) {
            case "transactions":
                return metaData.supportsTransactions();
            case "stored procedures":
                return metaData.supportsStoredProcedures();
            case "multiple result sets":
                return metaData.supportsMultipleResultSets();
            case "batch updates":
                return metaData.supportsBatchUpdates();
            case "savepoints":
                return metaData.supportsSavepoints();
            default:
                return false;
        }
    }

    private void cleanTestData() throws SQLException {
        if (connection == null) {
            connection = dataSource.getConnection();
        }
        
        // Clean up any test data that might exist
        // This will be expanded when actual entities are created
        Statement stmt = connection.createStatement();
        
        try {
            // Drop test tables if they exist (when JPA entities are created)
            // For now, just ensure we can execute statements
            stmt.executeQuery("SELECT 1");
        } catch (SQLException e) {
            // Ignore errors during cleanup
        }
    }
}